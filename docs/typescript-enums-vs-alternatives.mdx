---
title: "Are TypeScript Enums a Good Idea? (Bundle Size & Runtime)"
summary: "A practical guide to TypeScript enums, their runtime cost, and better alternatives for modern frontend apps."
publishedTime: "2025-12-30"
tags: ["typescript", "enums", "bundle-size", "performance", "frontend"]
---

# Are TypeScript Enums a Good Idea?

Short answer: **usually no**, especially in frontend apps where **bundle size and runtime behavior matter**.

TypeScript `enum`s look convenient, but they come with **hidden runtime costs**. In most cases, there are **better zero-cost alternatives**.

---

## ðŸ§  What Actually Happens with `enum`

### Numeric enum
```ts
enum Status {
  Idle,
  Loading,
  Success,
}
```

Generated JavaScript:
```js
var Status;
(function (Status) {
  Status[Status["Idle"] = 0] = "Idle";
  Status[Status["Loading"] = 1] = "Loading";
  Status[Status["Success"] = 2] = "Success";
})(Status || (Status = {}));
```

ðŸ‘‰ This means:
- A **real object exists at runtime**
- Extra bytes in your JS bundle
- Worse tree-shaking than you expect

---

### String enum
```ts
enum Mode {
  Light = "light",
  Dark = "dark",
}
```

Still generates a runtime object:
```js
var Mode = {
  Light: "light",
  Dark: "dark",
};
```

Better than numeric enums, but still **not free**.

---

## âš ï¸ Why Enums Can Be a Problem

- âŒ Increase bundle size
- âŒ Add runtime objects
- âŒ Harder to tree-shake
- âŒ Easy to misuse for simple unions

Enums are **not erased** by TypeScript.

---

## âš¡ What About `const enum`?

```ts
const enum Status {
  Idle,
  Loading,
}
```

- âœ… Inlined at compile time
- âœ… Zero runtime cost
- âŒ Often incompatible with Babel / SWC / isolatedModules
- âŒ Risky in monorepos or mixed build setups

âš ï¸ Use only if you fully control your toolchain.

---

## âœ… Better Alternatives (Recommended)

### 1ï¸âƒ£ String Literal Unions (Best Default)

```ts
type Mode = "light" | "dark";
```

- âœ… Zero runtime cost
- âœ… Perfect for props, state, API types
- âŒ No runtime list (by default)

Pair with a list if needed:

```ts
export const MODES = ["light", "dark"] as const;
export type Mode = (typeof MODES)[number];
```

---

### 2ï¸âƒ£ `as const` Object Pattern (Enum-like DX)

```ts
export const Mode = {
  Light: "light",
  Dark: "dark",
} as const;

export type Mode = typeof Mode[keyof typeof Mode];
```

- âœ… Small runtime footprint
- âœ… Tree-shakable
- âœ… Nice DX: `Mode.Dark`
- âœ… Works well with runtime validation

---

### 3ï¸âƒ£ Schema-first (APIs, forms)

```ts
const ROLES = ["admin", "user"] as const;
type Role = (typeof ROLES)[number];
```

Great when used with Zod / Valibot for runtime validation.

---

## ðŸ§  When Enums Are Actually OK

Use real `enum` if:
- You **need runtime iteration**
- You rely on **reverse mapping**
- You integrate with legacy code
- Bundle size is not critical

Enums are not evil â€” just **often overused**.

---

## ðŸ“Š Comparison Table

| Pattern | Runtime cost | Tree-shaking | DX | Recommended |
|------|--------------|--------------|----|------------|
| enum | âŒ | âŒ | âœ… | âš ï¸ |
| const enum | âœ… | âœ… | âš ï¸ | âš ï¸ |
| union type | âœ… | âœ… | âœ… | â­ |
| as const object | âœ… | âœ… | âœ… | â­â­ |

---

## âœ… Final Recommendation

> **Prefer unions and `as const` objects in frontend TypeScript.**  
> Reach for `enum` only when you truly need runtime behavior.

This approach gives you:
- Smaller bundles
- Faster startup
- Clearer intent
- Fewer build surprises
