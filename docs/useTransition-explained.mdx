---
title: "useTransition Explained: Make React Feel Instant"
summary: "How useTransition works under the hood, when to use it, and how it differs from useDeferredValue."
publishedTime: "2025-12-12"
tags: ["react", "hooks", "concurrent", "performance", "ux"]
---

# useTransition Explained

`useTransition` is a React 18+ **concurrent hook** that lets you mark some state updates as **non-urgent**.

This helps your app stay responsive by making React prioritize:
- âœ… urgent updates (typing, clicking, input responsiveness)
over
- â³ slow UI updates (big list rendering, expensive filtering, heavy page transitions)

---

## ğŸ§© The Problem It Solves

Imagine a search input where filtering is heavy:

- User types: input updates
- At the same time, you render a huge list based on the text

Without `useTransition`, React treats both as equally urgent â†’ typing can feel laggy.

---

## âš™ï¸ Basic API

```tsx
import { useTransition, useState } from "react";

export default function SearchPage({ items }: { items: string[] }) {
  const [query, setQuery] = useState("");
  const [filter, setFilter] = useState("");
  const [isPending, startTransition] = useTransition();

  function onChange(e: React.ChangeEvent<HTMLInputElement>) {
    const value = e.target.value;

    // âœ… urgent: update input right away
    setQuery(value);

    // â³ non-urgent: update expensive list/filter
    startTransition(() => {
      setFilter(value);
    });
  }

  const filtered = items.filter((x) => x.includes(filter));

  return (
    <div>
      <input value={query} onChange={onChange} />
      {isPending && <p>Updating resultsâ€¦</p>}
      <ul>
        {filtered.map((x) => (
          <li key={x}>{x}</li>
        ))}
      </ul>
    </div>
  );
}
```

### What you get
- `startTransition(fn)` marks updates inside as **transition** (low priority).
- `isPending` becomes `true` while React is working on those updates.

---

## ğŸ§  Mental Model

Think of React updates like a queue with priorities:

- **Urgent lane**: typing, clicks, pointer movement
- **Transition lane**: slow rendering that can wait

`startTransition` moves updates into the **transition lane**.

So the user experience becomes:
- input stays snappy âœ…
- expensive rendering happens a bit later â³

---

## ğŸ” How It Works Under the Hood

React Fiber + Scheduler does this:

1. `setQuery(value)` schedules an **urgent update**.
2. `startTransition(() => setFilter(value))` schedules a **low priority update**.
3. If the user keeps typing, React may:
   - pause the low priority render
   - restart it with the latest value
   - skip intermediate renders

Thatâ€™s why transitions feel smooth: React avoids wasting work.

---

## âš¡ useTransition vs useDeferredValue

| Feature | useTransition | useDeferredValue |
|--------|---------------|------------------|
| You control | a state update | a derived value |
| API style | Active (`startTransition`) | Passive (`useDeferredValue(value)`) |
| Pending indicator | âœ… `isPending` | âŒ no built-in pending |
| Best for | triggering work | delaying derived rendering |
| Typical use | page transitions, filtering | search input results, previews |

**Rule of thumb**
- Use **useTransition** when you want to say: â€œthis update can wait.â€
- Use **useDeferredValue** when you want: â€œrender using an older value until you have time.â€

---

## âœ… Great Use Cases

- Filtering large lists
- Switching tabs with heavy content
- Updating charts
- Navigating to a route that triggers lots of work
- Anything where â€œloading/pendingâ€ UX helps

---

## âš ï¸ What useTransition is NOT

- âŒ It is **not** debounce/throttle
- âŒ It does **not** run work in a separate thread
- âŒ It doesnâ€™t magically make slow code fast â€” it just makes the UI stay responsive

If your render is extremely slow, consider:
- memoization (`useMemo`, `React.memo`)
- virtualization (react-window)
- splitting components / code-splitting
- improving algorithms

---

## ğŸ§± Common Mistakes

### 1) Putting urgent updates inside transition
```tsx
startTransition(() => {
  setQuery(value); // âŒ makes typing laggy
});
```
Keep input updates urgent.

### 2) Creating new heavy objects on every render
If your filtered list is recomputed every render, also consider memoizing or pre-indexing.

---

## ğŸ” `isPending` UX pattern

```tsx
{isPending ? <Spinner /> : <Results />}
```

or keep results visible and show subtle hint:

```tsx
{isPending && <small>Updatingâ€¦</small>}
```

---

## âœ… Summary

- `useTransition` marks updates as **low priority**.
- It protects user input from being blocked by heavy renders.
- Powered by **Fiber + Scheduler**, React can pause/restart work.
- Pair it with good performance practices for best results.

âœ¨ **useTransition makes React apps feel instant by keeping â€œurgent UIâ€ always responsive.**
