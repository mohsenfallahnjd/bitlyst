---
title: "React Fiber Explained: How Reactâ€™s Engine Actually Works"
summary: "A deep but clear explanation of React Fiber â€” the engine that powers modern React rendering and concurrency."
publishedTime: "2025-10-08"
tags: ["react", "fiber", "reconciliation", "concurrent", "react internals"]
---
React **Fiber** is the internal engine that powers Reactâ€™s rendering and reconciliation.  
Itâ€™s what makes Reactâ€™s updates smooth, interruptible, and concurrent.

---

## ğŸ§© What is React Fiber?

**React Fiber** is Reactâ€™s **reconciliation engine** â€” the system that decides *what* needs to be rendered and *when*.

Before React 16, React updates were **synchronous** and **blocking**. Once rendering started, React couldnâ€™t pause or reprioritize work â€” large trees could freeze the UI.

Fiber was a complete rewrite that made Reactâ€™s rendering:
- â¸ **Interruptible**
- â± **Prioritized**
- ğŸ” **Incremental (chunked)**
- ğŸ’¾ **Recoverable (resumable)**

In short: **Fiber = Reactâ€™s virtual call stack for async rendering.**

---

## ğŸ•°ï¸ The Old Model (Before Fiber)

Before Fiber, React used a **recursive** rendering approach â€” like this:

```js
function renderTree(node) {
  node.render();
  node.children.forEach(renderTree);
}
```

- Large trees blocked the main thread.  
- The browser couldnâ€™t respond to user input until React finished.  
- No way to pause, abort, or prioritize rendering.

---

## âš¡ Fiber: The New Architecture

React Fiber breaks the rendering work into **small units of work**, called **fiber nodes**.

This lets React:
- Pause between chunks of work.
- Resume later if the browser is busy.
- Assign different priorities to updates.
- Reuse previous work if nothing changed.

So React no longer blocks the main thread â€” it cooperatively yields to the browser.

---

## ğŸ§± The Fiber Node Structure

Each React component is represented by a **Fiber node** â€” a JavaScript object with pointers and metadata.

| Field | Description |
|--------|--------------|
| `type` | The component or DOM type |
| `key` | Used for list diffing |
| `child`, `sibling`, `return` | Pointers to other fiber nodes (linked list tree) |
| `pendingProps`, `memoizedProps`, `memoizedState` | Stores component state & props |
| `flags` | Marks what changed (update, placement, deletion) |
| `alternate` | Link to the previous fiber (for diffing old vs new trees) |

ğŸ“˜ Think of it as two trees:
- **Current tree** â†’ whatâ€™s on screen.  
- **Work-in-progress tree** â†’ what React is preparing.

When ready, React **commits** the new tree and swaps references.

---

## ğŸ” The Two Phases of Rendering

### 1ï¸âƒ£ Render Phase (Reconciliation)
- React builds a new Fiber tree (work-in-progress).
- Diffs elements vs previous render.
- Calculates what to change.
- Can be **paused, aborted, or restarted**.

### 2ï¸âƒ£ Commit Phase
- React applies all DOM mutations.
- Runs effects (`useEffect`, `componentDidMount`, etc.).
- This phase is **synchronous** â€” React cannot pause it.

ğŸ§  Render phase = â€œthinkingâ€  
âš¡ Commit phase = â€œdoingâ€

---

## ğŸ§  Scheduling and Priority

Fiber works with Reactâ€™s **scheduler**, which assigns priority to updates:

| Priority | Example |
|-----------|----------|
| Immediate | User input (typing, clicking) |
| High | Animations |
| Normal | State updates |
| Low | Background tasks |
| Idle | Prefetch, pre-render |

React checks between chunks:
> â€œBrowser, do you have time? If not, Iâ€™ll yield and resume later.â€

This is what enables **Concurrent Rendering**.

---

## âš™ï¸ Concurrent React (Fiber + Scheduler)

With **Concurrent Mode (React 18+)**, Fiber can prepare multiple UI versions in parallel.

React can:
- Prepare new UI while showing the old one.  
- Cancel or pause updates mid-render.  
- Prioritize urgent updates (like typing).

Example:

```tsx
const [isPending, startTransition] = useTransition();

function handleInput(e) {
  const value = e.target.value;
  startTransition(() => setFilter(value)); // low priority render
}
```

React keeps input responsive because it renders background updates at a lower priority.

---

## ğŸ§¬ Visualization

```
      [Root Fiber]
          â”‚
    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”
 [App]        [Modal]
   â”‚              â”‚
 [Header]       [Button]
```

Each node is a **Fiber** linked by `child`, `sibling`, and `return`.  
React walks this structure instead of the JS call stack â€” so it can pause or resume at any point.

---

## ğŸ’¡ Key Benefits of Fiber

âœ… Interruptible, non-blocking rendering  
âœ… Priority scheduling for updates  
âœ… Recoverable rendering (pause/resume)  
âœ… Enables Suspense, useTransition, and concurrent features  
âœ… Better error isolation and performance profiling

---

## ğŸ§  Why It Matters (Even if You Donâ€™t Use It Directly)

You donâ€™t write Fiber code yourself, but understanding it helps you reason about:
- Why React sometimes delays updates.
- Why â€œrenderâ€ can happen multiple times before commit.
- How `useTransition` and `Suspense` work.
- Why strict mode double-invokes renders (simulates concurrency).

---

## âœ… Summary

| Concept | Description |
|----------|--------------|
| **Fiber** | Reactâ€™s internal unit of work for rendering |
| **Fiber Node** | Represents one component or element |
| **Render Phase** | Diff & prepare work (async, interruptible) |
| **Commit Phase** | Apply updates (sync) |
| **Scheduler** | Manages priorities of updates |
| **Concurrent Rendering** | Lets React multitask smoothly |

âœ¨ **React Fiber turned React from a recursive renderer into an asynchronous virtual machine for UI.**  
Itâ€™s the reason React 18 feels fast, smooth, and intelligent.
