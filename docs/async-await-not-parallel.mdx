---
title: "Why async/await Doesnâ€™t Make JavaScript Code Parallel"
summary: "Async/await feels like parallel code, but it isnâ€™t. Hereâ€™s why JavaScript is still single-threaded and how async really works."
publishedTime: "2025-12-30"
tags: ["javascript", "async", "await", "promises", "event loop"]
---

# Why async/await Doesnâ€™t Make JavaScript Code Parallel

`async/await` often *looks* like parallel code, but it **does not make JavaScript run in parallel**.

Understanding this distinction is crucial for:
- performance tuning
- avoiding UI freezes
- writing correct async logic

---

## ðŸ§  The Core Truth

> **`async/await` is just syntax sugar over Promises.**  
> It makes async code *look synchronous*, but execution is still **single-threaded**.

---

## âŒ Common Misconception

```js
await fetch("/a");
await fetch("/b");
await fetch("/c");
```

Many people think:
> â€œThese run in parallel because they are async.â€

âŒ **Wrong** â€” they run **sequentially**.

Each `await` waits for the previous one to finish **before starting the next**.

---

## âœ… What Actually Runs in Parallel

Only **I/O handled by the runtime** (browser or Node.js) can run concurrently:
- Network requests
- Timers
- File system operations (Node)
- Database calls

JavaScript code itself **never runs in parallel** on a single thread.

---

## ðŸ” What `await` Really Does

When JavaScript sees:

```js
await promise;
```

It does **three things**:

1. Pauses the current function
2. Returns control to the event loop
3. Resumes later when the Promise resolves

âž¡ï¸ No new thread is created.  
âž¡ï¸ No parallel JS execution happens.

---

## ðŸ§ª Sequential vs Concurrent Example

### âŒ Sequential (slow)

```js
await fetch("/a");
await fetch("/b");
await fetch("/c");
```

Timeline:
```
A â”€â”€â”€â–º B â”€â”€â”€â–º C
```

---

### âœ… Concurrent (correct)

```js
const a = fetch("/a");
const b = fetch("/b");
const c = fetch("/c");

await Promise.all([a, b, c]);
```

Timeline:
```
A â”€â”€â”€â”€â”€â”€â”
B â”€â”€â”€â”€â”€â”€â”¼â”€â”€â–º await
C â”€â”€â”€â”€â”€â”€â”˜
```

Here:
- Requests run concurrently (outside JS)
- JS still resumes once, not in parallel

---

## âš ï¸ async/await vs CPU Work

This **still blocks** the UI:

```js
async function bad() {
  await heavyCpuTask(); // âŒ still blocks
}
```

Because:
- CPU-heavy work runs on the JS thread
- `await` does not offload computation

If you need real parallel CPU work:
- Web Workers (browser)
- Worker Threads (Node.js)

---

## ðŸ§  Mental Model

- **async/await** = *pause & resume*
- **Promise** = *future value*
- **Event loop** = *scheduler*
- **Parallelism** = *multiple threads* (JS does not have this)

Think of `await` as:
> â€œPause here, let other JS run, come back later.â€

---

## ðŸ” Why async/await Still Feels Faster

Even though itâ€™s not parallel:
- JS thread stays free while waiting
- UI stays responsive
- Multiple I/O tasks overlap

So apps *feel* faster â€” but computation is still single-threaded.

---

## ðŸ§± When You Actually Get Parallelism

| Scenario | Parallel? |
|--------|----------|
| `await fetch()` | âŒ JS / âœ… I/O |
| `Promise.all(fetches)` | âŒ JS / âœ… I/O |
| CPU loop | âŒ |
| Web Worker | âœ… |
| Node worker_threads | âœ… |

---

## âœ… Summary

| Concept | Reality |
|------|--------|
| async/await | Syntax sugar |
| JS execution | Single-threaded |
| I/O | Concurrent |
| CPU work | Blocking |
| Promise.all | Concurrency, not parallelism |

---

## âœ¨ Final Takeaway

> **async/await makes asynchronous code readable â€” not parallel.**  
> For parallel execution, you need multiple threads (workers), not syntax.

---

### Suggested follow-ups
- Event Loop: microtasks vs macrotasks  
- Promise.all vs Promise.allSettled vs Promise.race  
- Web Workers vs async/await
